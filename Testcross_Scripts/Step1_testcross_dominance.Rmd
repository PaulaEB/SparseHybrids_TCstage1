---
title: "Stage1: testcross_dominance_GRM loop"
author: "PaulaE"
date: "2026-01-20"
output: html_document
---

**Research question**

How many testers are required to estimate GCA accurately for the mother's pool (pool A) in the presence of dominance for rapid parent selection? 


Compare the GCA estimates from a testcross with different number of testers vs the true GCA from the full factorial cross with with different dominance.

1. Defining parameters for the testcross simulation in a maize hybrid breeding program based on Gonzalez-Dieguez et al. and 2025, Bančič et al., 2024; and parameters for the experimental design based on Tolhurst (Genome-wide association studies - Single environment simulation).

Adding SNPs to calculate the Genomic Relationship Matrix. Here I set an overlap for the SNPs and QTL (~50%).

Here if I add the dominance levels as three different traits may be noisy as the simulation would add diferent addEff and domEff for each trait... not comparable because the effects are different??

```{r Simulation parameters}
rm(list = ls())
# .rs.restartR()
library(AlphaSimR)
library(FieldSimR)
library(dplyr)
library(tibble)

# Testcross parameters
nparents <- 80 #Number of parents in both pools
nchr <- 10 #Number of chromosomes in maize
nqtl <- 500 #Lit causal QTL for a trait. So total is nchr x nqtl = 5000 QTL
nsnps <- 500 # Markers not necessarily in LD with QTL of with effects on the trait
nGenSplit = 50 #Heterotic pool split
# ntesters <- 3 #number of testers for the testcrosses
# ncrosses <- 60

# Trait parameters
meanG <- 70
varG <- 20
h2 <- 0.3 # plot-level heritability, ratio of genetic to phenotypic variance, varG/(varG + varE)
meanDD <- 0.9 #high dominance according to Gonzalez-Dieguez 2025
# meanDD_medium <- 0.5 #medium dominance according to Gonzalez-Dieguez 2025
# meanDD_low <- 0.2 #low dominance according to Gonzalez-Dieguez 2025
varDD <- 0.2

# Experimental design parameters: full factorial
nenvs <- 1
nblocks <- nreps <- 2
ngenos_ff <- (nparents/2)*(nparents/2)

# Experimental design parameters: testcross
nenvs <- 1
nblocks <- nreps <- 2
ngenos_tc <- (nparents/2) * 1 #number of hybrids in the testcross with 3 testers
nplots_tc <- ngenos_tc*nblocks
ncols_tc <- 8 # define number of columns in the field 
nrows_tc <- nplots_tc/ncols_tc # define number of rows from the number of columns

```

2. Simulate the founder population of inbreds with a historic population split of 50 generations to create two heterotic pools with drift (more related to the haplotype blocks... not necessarily related to heterosis). Also add two traits: one additive (Trait 1) and one with high dominance (Trait 2). 

Important: allow overlapping of SNPs and QTL (optimistic scenario where we can match most of the QTL in the SNPchip)

```{r Founder genomes}
founderpop <- runMacs(nInd=nparents, 
                      nChr=nchr, 
                      segSites= (nsnps+nqtl), #number of segregating sites per chromosome 1000 * 10= 10,000 sites
                      inbred=TRUE,
                      species="MAIZE",
                      split = nGenSplit)

SP <- SimParam$new(founderpop)
SP$setTrackPed(TRUE)
SP$restrSegSites(minSnpPerChr = nsnps, overlap = T)
SP$addSnpChip(nsnps)
SP$addTraitA(nQtlPerChr=nqtl, mean=meanG, var=varG)
SP$addTraitAD(nQtlPerChr=nqtl, mean = meanG, var = varG, meanDD = meanDD, varDD = varDD) #mean dominance degree and variance of the dominance degree

```

2. Simulate both heterotic pools. Pool A = mother's pool. Pool B = father's pool (testers).

```{r Heterotic pools}
poolA <- newPop(founderpop[1:(nparents/2)])
poolB <- newPop(founderpop[((nparents/2)+1):(nparents)])

table(poolA@id)
# popVar(poolA@gv[,1])
# popVar(poolA@gv[,2])
# popVar(poolA@bv[,1])
# poolA
# varA(poolA)
# popVar(bv(poolA))
# popVar(gv(poolA))
# dd(poolA)
table(poolB@id)
 
```
2.1. Check allele frequencies between pools from the genotypes. The QTL are **not** the same for SNP genotypes (SNP chip added), pullQtlGeno() and pullSegSiteGeno() will **not** be the same.

Between pools, the SNPs and QTL are the same **but the allelic dosages are different** because of the split parameter (drift). So:

* M_segsites is the matrix for all (10k) segregating sites (SNP+QTL sites). Used to assess the population structure and check the divergence.
* M_snps is the matrix for the SNPs only (5k). Used for the GRM calculation.
* M_qtl is the matrix for the causal loci for a trait (QTL) (5k). Used to calculate heterosis 

```{r Correlation between allele frequencies}

M_segsitesA <- pullSegSiteGeno(poolA)
dim(M_segsitesA) # it should be the individuals in pool A (rows) and the number of QTL (columns). This is noted by chromosome_locus.
M_snpsA <- pullSnpGeno(poolA)
dim(M_snpsA) 
M_qtlA <- pullQtlGeno(poolA)
dim(M_qtlA)
sum(colnames(M_snpsA) %in% colnames(M_qtlA)) #some overlap, around 50% (2481 out of 5000)

M_segsitesB <- pullSegSiteGeno(poolB)
dim(M_segsitesB) # it should be the individuals in pool A (rows) and the number of QTL (columns). This is noted by chromosome_locus.
M_snpsB <- pullSnpGeno(poolB)
dim(M_snpsB) 
M_qtlB <- pullQtlGeno(poolB)
dim(M_qtlB)
sum(colnames(M_snpsB) %in% colnames(M_qtlB)) #some overlap, around 45% (2217 out of 5000)

identical(M_snpsA,M_snpsB) # False, same sites but different allelic dosages 

# Calculate the allele frequencies per pool with all the sites 
alleleFreqs_sitesA <- colMeans(M_segsitesA)/2 #divide by 2 because it is a diploid and we have the allele dosages 
length(alleleFreqs_sitesA)
alleleFreqs_sitesB <- colMeans(M_segsitesB)/2
length(alleleFreqs_sitesB)

cor(alleleFreqs_sitesA, alleleFreqs_sitesB) # the frequencies of the two pools are correlated positively, but it does not mean that are not delivering heterosis (theoretically~-1), it depends on the QTL effects and dominance 
mean(abs(alleleFreqs_sitesA - alleleFreqs_sitesB)) # this mean does not consider the direction of the allele frequency difference
plot(alleleFreqs_sitesA, alleleFreqs_sitesB,
     xlab = "Allele frequencies Pool A",
     ylab = "Allele frequencies Pool B",
     main = paste0("Allele frequencies between pools with split = ", nGenSplit),
     pch = 1, col = "grey60")
abline(0,1, lwd = 2)
legend("topleft",
       legend = sprintf("correlation = %.3f", cor(alleleFreqs_sitesA, alleleFreqs_sitesB)),
       bty = "n")

```
Run a PCA for pop structure of both pools using all the sites.

```{r Population structure between pools}
# PCA between pools
G <- rbind(M_snpsA, M_snpsB)
pools <- factor(c(rep("A", nrow(M_segsitesA)), rep("B", nrow(M_segsitesB))))
pc <- prcomp(G, center = TRUE, scale. = FALSE)
summary(pc)
#Variance explained 2 components
M_vaf1 <- 100*pc$sdev[1]^2/sum(pc$sdev^2)
M_vaf2 <- 100*pc$sdev[2]^2/sum(pc$sdev^2)

plot(pc$x[,1], pc$x[,2],
     col = c("A"="purple","B"="black")[pools], pch = 19,
     xlab = sprintf("PC1 (%.1f%%)", M_vaf1),
     ylab = sprintf("PC2 (%.1f%%)", M_vaf2), main = "Between pools")

legend("topright", c("Pool A","Pool B"), col = c("purple","black"), pch = 19, bty = "n")

```

Check population structure within pools using all the sites

```{r Population structure within pools}
par(mfrow=c(1,2))

# PCA pool A
pc_poolA <- prcomp(M_segsitesA, center = TRUE, scale. = FALSE)
summary(pc_poolA)
#Variance explained 2 components
M_vaf1_poolA <- 100*pc_poolA$sdev[1]^2/sum(pc_poolA$sdev^2)
M_vaf2_poolA <- 100*pc_poolA$sdev[2]^2/sum(pc_poolA$sdev^2)

plot(pc_poolA$x[,1], pc_poolA$x[,2],
     col = "purple", 
     pch = 1, 
     xlab = sprintf("PC1 (%.1f%%)", M_vaf1_poolA),
     ylab = sprintf("PC2 (%.1f%%)", M_vaf2_poolA))

# PCA pool B
pc_poolB <- prcomp(M_segsitesB, center = TRUE, scale. = FALSE)
summary(pc_poolB)
#Variance explained 2 components
M_vaf1_poolB <- 100*pc_poolB$sdev[1]^2/sum(pc_poolB$sdev^2)
M_vaf2_poolB <- 100*pc_poolB$sdev[2]^2/sum(pc_poolB$sdev^2)

plot(pc_poolB$x[,1], pc_poolB$x[,2],
     col = "black",
     pch = 1,
     xlab = sprintf("PC1 (%.1f%%)", M_vaf1_poolB),
     ylab = sprintf("PC2 (%.1f%%)", M_vaf2_poolB))
```

Check mean and variance of genetic values for the traits in the parental pools

```{r Traits in the pools}
cat("Both traits: PoolA meanG","\n")
meanG(poolA)
cat("Both traits: PoolA varG","\n")
varG(poolA)
cat("Both traits: PoolB meanG","\n")
meanG(poolB)
cat("Both traits: PoolB varG","\n")
varG(poolB)

par(mfrow=c(1,2))
hist(poolA@gv[,1], breaks = 10, main = sprintf("GV PoolA trait1\n(mean = %.2f, var = %.2f)",
                    mean(poolA@gv[,1]), popVar(poolA@gv[,1])))
abline(v = mean(poolA@gv[,1]), col = "purple4", lty = 1, lwd = 3)
hist(poolA@gv[,2], breaks = 10, main = sprintf("GV PoolA trait2\n(mean = %.2f, var = %.2f)",
                    mean(poolA@gv[,2]), popVar(poolA@gv[,2])))
abline(v = mean(poolA@gv[,2]), col = "purple4", lty = 1, lwd = 3)
par(mfrow=c(1,1))
par(mfrow=c(1,2))
hist(poolB@gv[,1], breaks = 10, main = sprintf("GV PoolB trait1\n(mean = %.2f, var = %.2f)",
                    mean(poolB@gv[,1]), popVar(poolB@gv[,1])))
abline(v = mean(poolB@gv[,1]), col = "grey20", lty = 1, lwd = 3)
hist(poolB@gv[,2], breaks = 10, main = sprintf("GV PoolB trait2\n(mean = %.2f, var = %.2f)",
                    mean(poolB@gv[,2]), popVar(poolB@gv[,2])))
abline(v = mean(poolB@gv[,2]), col = "black", lty = 1, lwd = 3)
```

**Hybrid cross**

```{r Hybrids}
#Factorial cross: "testcross" for all possible combinations
hybridpop <- hybridCross(females = poolA,
                         males = poolB, 
                         crossPlan = "testcross")

table(hybridpop@mother)
table(hybridpop@father)

cat("Both traits: Hybrid population meanG","\n")
meanG(hybridpop)
cat("Both traits: Hybrid population varG","\n")
varG(hybridpop)

```
Histogram of genetic values of the pools and the hybrids for both traits

```{r Genetic values of the pools and hybrids}
hist(hybridpop@gv[,1], breaks = 10, freq = FALSE,
     xlim = range(c(hybridpop@gv[,1], poolA@gv[,1], poolB@gv[,1])),
     col = adjustcolor("#FFC20A", 0.30), border = NA,
     main = sprintf("GV Trait1\nHybrids mean=%.2f var=%.2f\nPoolA mean=%.2f var=%.2f\nPoolB mean=%.2f var=%.2f",
                    mean(hybridpop@gv[,1]), popVar(hybridpop@gv[,1]),
                    mean(poolA@gv[,1]),     popVar(poolA@gv[,1]),
                    mean(poolB@gv[,1]),     popVar(poolB@gv[,1])))

# Add pool A
hist(poolA@gv[,1], breaks = 10, add = TRUE, freq = FALSE,
     col = adjustcolor("purple2", 0.25), border = NA)

# Add pool B
hist(poolB@gv[,1], breaks = 10, add = TRUE, freq = FALSE,
     col = adjustcolor("grey20", 0.25), border = NA)

legend("topleft", bty = "n",
       legend = c("Hybrids", "Pool A", "Pool B"),
       fill = c("#FFC20A", "purple2", "grey20"),
       border = NA)

abline(v = mean(hybridpop@gv[,1]), col = "#FFC20A",    lty = 1, lwd = 3)
abline(v = mean(poolA@gv[,1]),     col = "purple2", lty = 1, lwd = 3)
abline(v = mean(poolB@gv[,1]),     col = "grey20", lty = 1, lwd = 3)

hist(hybridpop@gv[,2], breaks = 10, freq = FALSE,
     xlim = range(c(hybridpop@gv[,2], poolA@gv[,2], poolB@gv[,2])),
     col = adjustcolor("#FFC20A", 0.30), border = NA,
     main = sprintf("GV Trait2\nHybrids mean=%.2f var=%.2f\nPoolA mean=%.2f var=%.2f\nPoolB mean=%.2f var=%.2f",
                    mean(hybridpop@gv[,2]), popVar(hybridpop@gv[,2]),
                    mean(poolA@gv[,2]),     popVar(poolA@gv[,2]),
                    mean(poolB@gv[,2]),     popVar(poolB@gv[,2])))

# Add pool A
hist(poolA@gv[,2], breaks = 10, add = TRUE, freq = FALSE,
     col = adjustcolor("purple2", 0.40), border = NA)

# Add pool B
hist(poolB@gv[,2], breaks = 10, add = TRUE, freq = FALSE,
     col = adjustcolor("grey20", 0.40), border = NA)

legend("topleft", bty = "n",
       legend = c("Hybrids", "Pool A", "Pool B"),
       fill = c("#FFC20A", "purple2", "grey20"),
       border = NA)

abline(v = mean(hybridpop@gv[,2]), col = "#FFC20A",    lty = 1, lwd = 3)
abline(v = mean(poolA@gv[,2]),     col = "purple2", lty = 1, lwd = 3)
abline(v = mean(poolB@gv[,2]),     col = "grey20", lty = 1, lwd = 3)

```

Run a PCA for the full population with all the sites

```{r Population structure of the pools and hybrids}

M_segsiteshybrid <- pullSegSiteGeno(hybridpop)
G_all<-rbind(M_segsitesA, M_segsitesB, M_segsiteshybrid)
grp <- factor(c(rep("H", nrow(M_segsiteshybrid)),
                rep("A", nrow(M_qtlA)),
                rep("B", nrow(M_qtlB))),
              levels = c("H","A","B"))

pc_all <- prcomp(G_all, center = TRUE, scale. = FALSE)
varExp <- pc_all$sdev^2 / sum(pc_all$sdev^2)

colors <- c(H = "#FFC20A", A = "purple", B = "black")
pchs <- c(H = 1, A = 19, B = 19)

plot(pc_all$x[grp=="H",1], pc_all$x[grp=="H",2],
     col = colors["H"], pch = pchs["H"], cex = 0.9,
     xlab = sprintf("PC1 (%.1f%%)", 100*varExp[1]),
     ylab = sprintf("PC2 (%.1f%%)", 100*varExp[2]),
     main = "All")

points(pc_all$x[grp=="A",1], pc_all$x[grp=="A",2],
       col = colors["A"], pch = pchs["A"], cex = 1.2)
points(pc_all$x[grp=="B",1], pc_all$x[grp=="B",2],
       col = colors["B"], pch = pchs["B"], cex = 1.2)

legend("topright",
       legend = c("Hybrids","Pool A","Pool B"),
       col = colors[c("H","A","B")],
       pch = pchs[c("H","A","B")],
       pt.cex = c(0.9, 1.2, 1.2),
       bty = "n")

```

**Calculating the ground truth (GCA from a full factorial)**

We have the following pops:

1.  Parental lines: **Pool A** and **Pool B** each with 40 individuals
2.  Hybrids from the full factorial testcross: **hybridpop** with 1600 individuals

To calculate the GCA of the entire population of the full factorial cross, we need to create a dataset (gv_df) by extracting the genetic values from each parent combination (hybrid) in {hybridpop@gv}. As these are the genetic values, the two replicates have the same value.

```{r Genetic values of hybrids}
# Some cleaning
# keep <- c("founderpop", "poolA", "poolB", "hybridpop",
#           "nparents", "ntesters",
#           "meanG", "varG", "h2", 
#           "nenvs", "nreps", "ngenos_ff"#,"nplots_ff", "ncols_ff", "nrows_ff", 
#           )
# rm(list = setdiff(ls(), intersect(ls(), keep)))
# gc()

gv_df <- data.frame(env = 1,
                    mother_poolA = factor(as.numeric(hybridpop@mother)), #poolA
                    father_poolB = factor(as.numeric(hybridpop@father)), #poolB
                    id = factor(as.numeric(hybridpop@id)),
                    rep = factor(rep(1:nreps, each = ngenos_ff)),
                    gv.TraitA = as.numeric(hybridpop@gv[,1]), 
                    gv.TraitAD = as.numeric(hybridpop@gv[,2]))

gv_df <- gv_df[order(gv_df$mother_poolA, gv_df$father_poolB), ]
rbind((head(gv_df, n=2)), tail(gv_df, n=2))
```

Calculate the true GCA effects for the mothers pool A from the full factorial by calculating the average effect of each parent across all its crosses (mean per row in the case of the females and mean of the column in the case of the males), for the additive trait (trait1) {gv_table_trait1} and for the trait with high dominance {gv_table_trait2}

```{r GCA of full factorial}
# Create a matrix with the genetic values per combination of parents
gv_table_trait1 <- with(gv_df, tapply(gv.TraitA, list(mother_poolA, father_poolB), unique)) #matrix with the genetic values of the hybrids per combination of parents
colnames(gv_table_trait1) <- trimws(colnames(gv_table_trait1)) #tidy column names, removing extra spaces
pop_gv_mean_trait1 <- mean(gv_table_trait1) #mean of the population in general, same as meanG = 70
gv_table_trait1 <- gv_table_trait1 - pop_gv_mean_trait1 #genetic values without the intercept, so we can calculate the GCA effects directly
(head(gv_table_trait1, n=3))

gv_table_trait2 <- with(gv_df, tapply(gv.TraitAD, list(mother_poolA, father_poolB), unique)) #matrix with the genetic values of the hybrids per combination of parents
colnames(gv_table_trait2) <- trimws(colnames(gv_table_trait2)) #tidy column names, removing extra spaces
(pop_gv_mean_trait2 <- mean(gv_table_trait2)) #mean of the population in general, same as meanG = 70
gv_table_trait2 <- gv_table_trait2 - pop_gv_mean_trait2 #genetic values without the intercept, so we can calculate the GCA effects directly
(head(gv_table_trait2, n=3))

# Calculate true GCA effects (all parent combos) for pool A trait 1
gca_full_A_trait1 <- data.frame(
  mother_id = rownames(gv_table_trait1),
  GCA = rowMeans(gv_table_trait1))
mean(gca_full_A_trait1$GCA) 
# gca_full_B_trait1 <- colMeans(gv_table_trait1)
# mean(gca_full_B_trait1) 
# (mean(gv_table_trait1 - gca_full_A_trait1 - gca_full_B_trait1)) 

# Calculate true GCA effects (all parent combos) for pool A trait 2
(gca_full_A_trait2 <- data.frame(
  mother_id = rownames(gv_table_trait2),
  GCA = rowMeans(gv_table_trait2)))
mean(gca_full_A_trait2$GCA) 
# (gca_full_B_trait2 <- colMeans(gv_table_trait2))
# mean(gca_full_B_trait2) 
# (mean(gv_table_trait2 - gca_full_A_trait2 - gca_full_B_trait2)) 


par(mfrow=c(1,2))
hist(gca_full_A_trait1$GCA, breaks=20)
hist(gca_full_A_trait2$GCA, breaks=20)

par(mfrow=c(1,1))

barplot(gca_full_A_trait1$GCA, names.arg = gca_full_A_trait1$mother_id,
        las = 2, col = "purple2",cex.names = 0.7,
        ylab = "GCA", ylim = c(-7,7),
        main = sprintf("Trait1: GCA Pool A (var = %.3f)", var(gca_full_A_trait1$GCA)))
abline(h = 0, col = "black", lwd = 2)

barplot(gca_full_A_trait2$GCA, names.arg = gca_full_A_trait2$mother_id,
        las = 2, col = "purple2",cex.names = 0.7,
        ylab = "GCA", ylim = c(-7,7),
        main = sprintf("Trait2: GCA Pool A (var = %.3f)", var(gca_full_A_trait2$GCA)))
abline(h = 0, col = "black", lwd = 2)
```

Check if the top 10 of mothers are the same for both traits (just to see)

```{r Ranking}
top_n <- 10
length(intersect(gca_full_A_trait1$mother_id[order(gca_full_A_trait1$GCA, decreasing = TRUE)][1:top_n],
                              gca_full_A_trait2$mother_id[order(gca_full_A_trait2$GCA, decreasing = TRUE)][1:top_n]))
```
**Obtain the GRM from the SNP chip**

Calculate the GRM matrix for the pool A.

1. Calculate allele frequencies from SNPs in pool A
2. Centering the genotype matrix (Z)
3. Scale according VanRaden (K)
4. Calculate GRM with GRM = ZZ'/K

```{r}
alleleFreqs_snpA <- colMeans(M_snpsA)/2 #SNPj has an allele frequency pj, so this is allele frequency of the 40 mothers in every SNP not QTL
Z <- sweep(M_snpsA, 2, 2*alleleFreqs_snpA, "-") # the markers matrix from the SNPs (M_snpsA) in the mothers, apply by columns 2, 2pj substract so the mean is 0
K <- 2 * sum(alleleFreqs_snpA * (1 - alleleFreqs_snpA), na.rm = TRUE)
GRM_A <- (Z %*% t(Z)) #/ K
dim(GRM_A)
svd(GRM_A)$d
GRM_A <- GRM_A + diag(1e-5, nrow(GRM_A)) #add a small value to the diagonal to make it positive definite
GRM_A <- GRM_A/mean(diag(GRM_A)) #standardize the GRM so the mean of the diagonal is 1
```

```{r GCA from testcross 1 tester}

ntesters <- 1
testers_order <- sample(poolB@id, length(poolB@id), replace = FALSE)  # permutation of testers
nsamples <- length(testers_order)
top_n <- 10
top_true <- as.numeric(gca_full_A_trait2$mother_id[order(gca_full_A_trait2$GCA, decreasing = TRUE)][1:top_n])
cor_list <- cor_tc_list <- mean_list <- var_list <- ranking_intercept <- idx_list <- c()
for(i in 1:nsamples){
  print(i)
  
  # Subset of random testers from poolB
  ((idx_list[[i]] <- testers_idx <- testers_order[i])) #randomly sample testers from pool B without replacement
  # popVar((gv_table_trait2[, testers_idx])) # mean GCA females with the crosses with the 3 random testers
  # popVar(gca_full_A_trait2)
  # Correlation between the true GCA females from the full factorial cross and the GCA from the 3 testers
  gca_testcross_A_trait2 <- data.frame(mother_id = rownames(gv_table_trait2),
                                       GCA_tc = rowMeans(cbind(gv_table_trait2[, testers_idx])))
  
  # Environmental variance 
  gv_df_k_testers <- droplevels(gv_df[gv_df$father %in% testers_idx, ])
  
  # (varE <- diag(varG(hybridpop))/h2 - diag(varG(hybridpop))) 
  varE <- c(TraitA  = var(gv_df_k_testers$gv.TraitA)/h2 - var(gv_df_k_testers$gv.TraitA), 
            TraitAD = var(gv_df_k_testers$gv.TraitAD)/h2 - var(gv_df_k_testers$gv.TraitAD))
  error_df <- FieldSimR::field_trial_error(varR = varE,
                                           ntraits = 2,
                                           nenvs = nenvs,
                                           nblocks = nblocks,
                                           ncols = ncols_tc,
                                           nrows = nrows_tc,
                                           spatial.model = "AR1")
  gv_df2 <- gv_df_k_testers[, c(1, 4, 5, 6, 7)]
  pheno_df <- make_phenotypes(gv.df = gv_df2, error_df, randomise = T)
  pedigree <- gv_df_k_testers %>% select(id, mother_poolA, father_poolB) %>% distinct(id, .keep_all = TRUE)
  pheno_df <- pheno_df %>% left_join(pedigree, by = "id")
  
  #Obtaining GCA from the phenotypic data without a model
  pheno_gca_nomodels <- pheno_df %>% group_by(mother_poolA) %>% summarise(GCA_pheno = mean(y.Trait2)-mean(pheno_df$y.Trait2)) %>% ungroup()
  
  # Obtain the GCA using the three ASReml models
  
  model_testcross1 <- asreml(fixed = y.Trait2 ~ father_poolB - 1, 
                             random = ~ mother_poolA + block, 
                             residual = ~units,
                             data = pheno_df)
  plot(pheno_gca_nomodels$GCA_pheno, model_testcross1$coefficients$random[1:40])
  model_testcross2 <- asreml(fixed = y.Trait2 ~ father_poolB - 1, 
                             random = ~ mother_poolA +
                               block, 
                             residual = ~ar1(col):ar1(row),
                             data = pheno_df)
  plot(pheno_gca_nomodels$GCA_pheno, model_testcross2$coefficients$random[1:40])
  
  model_testcross3 <- asreml(fixed = y.Trait2 ~ father_poolB - 1, 
                             random = ~ vm(mother_poolA, GRM_A) +                                                     
                               block, 
                             residual = ~ar1(col):ar1(row),
                             data = pheno_df)
  
  m1 <- model_testcross1$coefficients$random %>% as.data.frame() %>% 
    rownames_to_column(var = "mother_id") %>% filter(grepl("^mother_poolA", mother_id)) %>% 
    mutate(mother_id = sub(".*_", "", mother_id), effect) 
  
  m2 <- model_testcross2$coefficients$random %>% as.data.frame() %>% 
    rownames_to_column(var = "mother_id") %>% filter(grepl("^mother_poolA", mother_id)) %>% 
    mutate(mother_id = sub(".*_", "", mother_id), effect)
  
  m3 <- model_testcross3$coefficients$random %>% as.data.frame() %>% 
    rownames_to_column(var = "mother_id") %>% filter(grepl("mother_poolA", mother_id)) %>% 
    mutate(mother_id = sub(".*_", "", mother_id), effect)
  
  top_tc_gv <- as.numeric(gca_testcross_A_trait2$mother_id[order(gca_testcross_A_trait2$GCA_tc, decreasing = TRUE)][1:top_n])
  top_tc_pheno_nomodel <- as.numeric(pheno_gca_nomodels$mother_poolA[order(pheno_gca_nomodels$GCA_pheno, decreasing = TRUE)][1:top_n])
  top_tc_gca_model1 <- as.numeric(m1$mother_id[order(m1$effect, decreasing = TRUE)][1:top_n])
  top_tc_gca_model2 <- as.numeric(m2$mother_id[order(m2$effect, decreasing = TRUE)][1:top_n])
  top_tc_gca_model3 <- as.numeric(m3$mother_id[order(m3$effect, decreasing = TRUE)][1:top_n])
  
  cor_list[[i]] <- data.frame( iter = i, tester= as.numeric(idx_list[[i]]),
                               gv_tc = cor(gca_full_A_trait2$GCA, gca_testcross_A_trait2$GCA_tc),
                               pheno = cor(gca_full_A_trait2$GCA, pheno_gca_nomodels$GCA_pheno),    
                               model1 = cor(gca_full_A_trait2$GCA, m1$effect),
                               model2 = cor(gca_full_A_trait2$GCA, m2$effect),
                               model3 = cor(gca_full_A_trait2$GCA, m3$effect))
  
  cor_tc_list[[i]] <- data.frame( iter = i, tester= as.numeric(idx_list[[i]]),
                               gv_tc = cor(gca_full_A_trait2$GCA, gca_testcross_A_trait2$GCA_tc),
                               pheno = cor(gca_testcross_A_trait2$GCA_tc, pheno_gca_nomodels$GCA_pheno),    
                               model1 = cor(gca_testcross_A_trait2$GCA_tc, m1$effect),
                               model2 = cor(gca_testcross_A_trait2$GCA_tc, m2$effect),
                               model3 = cor(gca_testcross_A_trait2$GCA_tc, m3$effect))
  
  mean_list[[i]] <- data.frame(iter = i, tester= as.numeric(idx_list[[i]]), 
                               gv_full=mean(gca_full_A_trait2$GCA),
                               gv_tc=mean(gca_testcross_A_trait2$GCA_tc),
                               pheno=mean(pheno_gca_nomodels$GCA_pheno),
                               model1=mean(m1$effect),
                               model2=mean(m2$effect),
                               model3=mean(m3$effect))
  
  var_list[[i]] <- data.frame(iter = i, tester= as.numeric(idx_list[[i]]), 
                              gv_full=popVar(gca_full_A_trait2$GCA), 
                              gv_tc=popVar(gca_testcross_A_trait2$GCA_tc), 
                              pheno=popVar(pheno_gca_nomodels$GCA_pheno), 
                              model1=popVar(m1$effect), 
                              model2=popVar(m2$effect), 
                              model3=popVar(m3$effect))
  
  ranking_intercept[[i]] <- data.frame(iter = i, tester = as.numeric(testers_idx),
                                  method = c("gv_tc", "pheno", "model1", "model2", "model3"),
                                  overlap= c(gv = length(intersect(top_true, top_tc_gv)),
                                             pheno = length(intersect(top_true, top_tc_pheno_nomodel)),  
                                             model1 = length(intersect(top_true, top_tc_gca_model1)),
                                             model2 = length(intersect(top_true, top_tc_gca_model2)),
                                             model3 = length(intersect(top_true, top_tc_gca_model3))))
  
}

# Summaries/plots
sort(unlist(idx_list))
cor_full_df <- dplyr::bind_rows(cor_list, .id = "iter") %>% arrange(tester)
cor_tc_df <- dplyr::bind_rows(cor_tc_list, .id = "iter") %>% arrange(tester)
mean_df <- dplyr::bind_rows(mean_list, .id = "iter")
var_df <- dplyr::bind_rows(var_list, .id = "iter") %>% arrange(tester)
rank_df <- bind_rows(ranking_intercept) %>% arrange(tester)

plot(cor_full_df$tester, cor_full_df$gv_tc, col = "green", lwd=2, ylim = c(0,1), type="l")
lines(cor_full_df$tester, cor_full_df$pheno, pch = 16, col = "blue")
lines(cor_full_df$tester, cor_full_df$model1, pch = 16, col = "pink")
lines(cor_full_df$tester, cor_full_df$model2, pch = 16, col = "magenta")
lines(cor_full_df$tester, cor_full_df$model3, pch = 16, col = "purple4")
legend("bottomright", legend = c("gv_tc","pheno","model1","model2","model3"),
       col = c("green","blue","pink","magenta","purple4"), lwd =1, bty = "n")

plot(cor_tc_df $tester, cor_tc_df $gv_tc, col = "green", lwd=2, ylim = c(0,1), type="l")
lines(cor_tc_df $tester, cor_tc_df $pheno, pch = 16, col = "blue")
lines(cor_tc_df $tester, cor_tc_df $model1, pch = 16, col = "pink")
lines(cor_tc_df $tester, cor_tc_df $model2, pch = 16, col = "magenta")
lines(cor_tc_df $tester, cor_tc_df $model3, pch = 16, col = "purple4")
legend("bottomright", legend = c("gv_tc","pheno","model1","model2","model3"),
       col = c("green","blue","pink","magenta","purple4"), lwd =1, bty = "n")

plot(var_df$tester, var_df$gv_full, pch=10,col = "green", type="l", lwd=2, ylim= range(var_df[, c("gv_full","gv_tc","pheno","model1","model2","model3")]))
lines(var_df$tester, var_df$gv_tc, pch = 16, col = "blue")
lines(var_df$tester, var_df$pheno, pch = 16, col = "black")
lines(var_df$tester, var_df$model1, pch = 16, col = "pink")
lines(var_df$tester, var_df$model2, pch = 16, col = "magenta")
lines(var_df$tester, var_df$model3, pch = 16, col = "purple4")
# points(var_df$tester, var_df$gv_tc,  col="blue",    pch=16)
# points(var_df$tester, var_df$pheno,  col="black",   pch=16)
# points(var_df$tester, var_df$model1, col="pink",    pch=16)
# points(var_df$tester, var_df$model2, col="magenta", pch=16)
# points(var_df$tester, var_df$model3, col="purple4", pch=16)
legend("topleft", legend = c("gv_full","gv_tc","pheno","model1","model2","model3"),
       col = c("green","blue","grey50","pink","magenta","purple4"), lwd =1, bty = "n")

boxplot(overlap ~ factor(method, levels = c("gv_tc","pheno","model1","model2","model3")), data = rank_df)
hist(rank_df$overlap[rank_df$method == "gv_tc"])
hist(rank_df$overlap[rank_df$method == "pheno"])
hist(rank_df$overlap[rank_df$method == "model1"])
hist(rank_df$overlap[rank_df$method == "model2"])
hist(rank_df$overlap[rank_df$method == "model3"])
plot_effects(error_df, effect = "e.Trait2")

#     cor_list[[i]] <- c((cor(gca_full_A_trait2$GCA, gca_testcross_A_trait2$GCA_tc)),cor(gca_full_A_trait2$GCA, pheno_gca_[ntesters]t_A_trait2$mean_y.Trait2), 
#                        cor(gca_full_A_trait2$GCA,asreml::predict(model_testcross1, classify = "mother_poolA", only = "mother_poolA")),
#                        cor(gca_full_A_trait2$GCA,asreml::predict(model_testcross2, classify = "mother_poolA", only = "mother_poolA")),
#                        cor(gca_full_A_trait2$GCA,asreml::predict(model_testcross3, classify = "mother_poolA", only = "mother_poolA")))
#     
#     mean_list[[i]] <- c(mean(gca_full_A_trait2$GCA), mean(gca_testcross_A_trait2$GCA_tc), mean(heno_gca_[ntesters]t_A_trait2$mean_y.Trait2),
#                         mean(asreml::predict(model_testcross1, classify = "mother_poolA", only = "mother_poolA")),
#                         mean(asreml::predict(model_testcross2, classify = "mother_poolA", only = "mother_poolA")),
#                         mean(asreml::predict(model_testcross3, classify = "mother_poolA", only = "mother_poolA"))))
# 
#     var_list[[i]] <- c(popVar(gca_full_A_trait2$GCA), popVar(gca_testcross_A_trait2$GCA_tc))
#     ranking_intercept[[i]] <- length(intersect(gca_full_A_trait2$mother_id[order(gca_full_A_trait2$GCA, decreasing = TRUE)][1:top_n],
#                               gca_testcross_A_trait2$mother_id[order(gca_testcross_A_trait2$GCA_tc, decreasing = TRUE)][1:top_n]))
# }
# sort(unlist(idx_list))
# plot_hist(unlist(cor_list))
# plot_hist(unlist(lapply(mean_list, function(x) x[1])))
# plot_hist(unlist(lapply(mean_list, function(x) x[2])))
# plot_hist(unlist(lapply(var_list, function(x) x[2])))
# plot(unlist(lapply(ranking_list, function(x) x[1])))
```
```{r}
ntesters <- 1
(choose(40, ntesters))
nsamples <- 40 #number of plots in Gonzalez-Dieguez
top_n <- 10
top_true <- as.numeric(gca_full_A_trait2$mother_id[order(gca_full_A_trait2$GCA, decreasing = TRUE)][1:top_n])
cor_list <- cor_tc_list <- mean_list <- var_list <- ranking_intercept <- idx_list <- c()

for(i in 1:nsamples){
  
  print(i)
  
    # Subset of random testers from poolB
  testers_idx <- sample(poolB@id, ntesters, replace = FALSE)  # permutation of testers
  
  idx_list[[i]] <- testers_idx  #randomly sample testers from pool B without replacement
  gca_testcross_A_trait2 <- data.frame(mother_id = rownames(gv_table_trait2),
                                       GCA_tc = rowMeans(cbind(gv_table_trait2[, testers_idx])))
  
  # Environmental variance 
  gv_df_k_testers <- droplevels(gv_df[gv_df$father %in% testers_idx, ])
  
  # (varE <- diag(varG(hybridpop))/h2 - diag(varG(hybridpop))) 
  varE <- c(TraitA  = var(gv_df_k_testers$gv.TraitA)/h2 - var(gv_df_k_testers$gv.TraitA), 
            TraitAD = var(gv_df_k_testers$gv.TraitAD)/h2 - var(gv_df_k_testers$gv.TraitAD))
  
  ngenos_tc_k <- 40 * ntesters
  nplots_tc_k <- ngenos_tc_k * nreps
  ncols_tc_k <- 10
  nrows_tc_k <- nplots_tc_k / ncols_tc_k
  
  error_df <- FieldSimR::field_trial_error(varR = varE,
                                           ntraits = 2,
                                           nenvs = nenvs,
                                           nblocks = nblocks,
                                           ncols = ncols_tc_k,
                                           nrows = nrows_tc_k,
                                           spatial.model = "AR1")

  gv_df2 <- gv_df_k_testers[, c(1, 4, 5, 6, 7)]
  pheno_df <- make_phenotypes(gv.df = gv_df2, error_df, randomise = T)
  pedigree <- gv_df_k_testers %>% select(id, mother_poolA, father_poolB) %>% distinct(id, .keep_all = TRUE)
  pheno_df <- pheno_df %>% left_join(pedigree, by = "id")
  
  #Obtaining GCA from the phenotypic data without a model
  pheno_gca_nomodels <- pheno_df %>% group_by(mother_poolA) %>% summarise(GCA_pheno = mean(y.Trait2)-mean(pheno_df$y.Trait2)) %>% ungroup()
  
  # Obtain the GCA using the three ASReml models
  
  model_testcross1 <- asreml(fixed = y.Trait2 ~ father_poolB - 1, 
                             random = ~ mother_poolA + block, 
                             residual = ~units,
                             data = pheno_df)
  
  model_testcross2 <- asreml(fixed = y.Trait2 ~ father_poolB - 1, 
                             random = ~ mother_poolA +
                               block, 
                             residual = ~ar1(col):ar1(row),
                             data = pheno_df)
  
  model_testcross3 <- asreml(fixed = y.Trait2 ~ father_poolB - 1, 
                             random = ~ vm(mother_poolA, GRM_A) +                                                      
                               block, 
                             residual = ~ar1(col):ar1(row),
                             data = pheno_df)
  
  m1 <- model_testcross1$coefficients$random %>% as.data.frame() %>% 
    rownames_to_column(var = "mother_id") %>% filter(grepl("^mother_poolA", mother_id)) %>% 
    mutate(mother_id = sub(".*_", "", mother_id), effect) 
  
  m2 <- model_testcross2$coefficients$random %>% as.data.frame() %>% 
    rownames_to_column(var = "mother_id") %>% filter(grepl("^mother_poolA", mother_id)) %>% 
    mutate(mother_id = sub(".*_", "", mother_id), effect)
  
  m3 <- model_testcross3$coefficients$random %>% as.data.frame() %>% 
    rownames_to_column(var = "mother_id") %>% filter(grepl("mother_poolA", mother_id)) %>% 
    mutate(mother_id = sub(".*_", "", mother_id), effect)
  
  top_tc_gv <- as.numeric(gca_testcross_A_trait2$mother_id[order(gca_testcross_A_trait2$GCA_tc, decreasing = TRUE)][1:top_n])
  top_tc_pheno_nomodel <- as.numeric(pheno_gca_nomodels$mother_poolA[order(pheno_gca_nomodels$GCA_pheno, decreasing = TRUE)][1:top_n])
  top_tc_gca_model1 <- as.numeric(m1$mother_id[order(m1$effect, decreasing = TRUE)][1:top_n])
  top_tc_gca_model2 <- as.numeric(m2$mother_id[order(m2$effect, decreasing = TRUE)][1:top_n])
  top_tc_gca_model3 <- as.numeric(m3$mother_id[order(m3$effect, decreasing = TRUE)][1:top_n])
  
  tester_set <- paste(sort(testers_idx), collapse = ",")

  cor_list[[i]] <- data.frame( iter = i, tester= tester_set,
                               gv_tc = cor(gca_full_A_trait2$GCA, gca_testcross_A_trait2$GCA_tc),
                               pheno = cor(gca_full_A_trait2$GCA, pheno_gca_nomodels$GCA_pheno),    
                               model1 = cor(gca_full_A_trait2$GCA, m1$effect),
                               model2 = cor(gca_full_A_trait2$GCA, m2$effect),
                               model3 = cor(gca_full_A_trait2$GCA, m3$effect))
  
  cor_tc_list[[i]] <- data.frame( iter = i, tester= tester_set,
                               gv_tc = cor(gca_full_A_trait2$GCA, gca_testcross_A_trait2$GCA_tc),
                               pheno = cor(gca_testcross_A_trait2$GCA_tc, pheno_gca_nomodels$GCA_pheno),    
                               model1 = cor(gca_testcross_A_trait2$GCA_tc, m1$effect),
                               model2 = cor(gca_testcross_A_trait2$GCA_tc, m2$effect),
                               model3 = cor(gca_testcross_A_trait2$GCA_tc, m3$effect))
  
  mean_list[[i]] <- data.frame(iter = i, tester= tester_set, 
                               gv_full=mean(gca_full_A_trait2$GCA),
                               gv_tc=mean(gca_testcross_A_trait2$GCA_tc),
                               pheno=mean(pheno_gca_nomodels$GCA_pheno),
                               model1=mean(m1$effect),
                               model2=mean(m2$effect),
                               model3=mean(m3$effect))
  
  var_list[[i]] <- data.frame(iter = i, tester= tester_set, 
                              gv_full=popVar(gca_full_A_trait2$GCA), 
                              gv_tc=popVar(gca_testcross_A_trait2$GCA_tc), 
                              pheno=popVar(pheno_gca_nomodels$GCA_pheno), 
                              model1=popVar(m1$effect), 
                              model2=popVar(m2$effect), 
                              model3=popVar(m3$effect))
  
  ranking_intercept[[i]] <- data.frame(iter = i, tester = tester_set,
                                  method = c("gv_tc", "pheno", "model1", "model2", "model3"),
                                  overlap= c(gv = length(intersect(top_true, top_tc_gv)),
                                             pheno = length(intersect(top_true, top_tc_pheno_nomodel)),  
                                             model1 = length(intersect(top_true, top_tc_gca_model1)),
                                             model2 = length(intersect(top_true, top_tc_gca_model2)),
                                             model3 = length(intersect(top_true, top_tc_gca_model3))))
  
}

# Summaries/plots
sort(unlist(idx_list))
cor_full_df <- dplyr::bind_rows(cor_list, .id = "iter") %>% arrange(tester)
cor_tc_df <- dplyr::bind_rows(cor_tc_list, .id = "iter") %>% arrange(tester)
mean_df <- dplyr::bind_rows(mean_list, .id = "iter")
var_df <- dplyr::bind_rows(var_list, .id = "iter") %>% arrange(tester)
rank_df <- bind_rows(ranking_intercept) %>% arrange(tester)

hist(cor_full_df$gv_tc,main = sprintf("Cor mean = %.3f", mean(cor_full_df$gv_tc)))

hist(cor_full_df$pheno, main = sprintf("Cor mean = %.3f", mean(cor_full_df$pheno)))
hist(cor_tc_df$pheno, main = sprintf("Cor mean = %.3f", mean(cor_tc_df$pheno)))

hist(cor_full_df$model1, main = sprintf("Cor mean = %.3f", mean(cor_full_df$model1)))
hist(cor_tc_df$model1, main = sprintf("Cor mean = %.3f", mean(cor_tc_df$model1)))

hist(cor_full_df$model2, main = sprintf("Cor mean = %.3f", mean(cor_full_df$model2)))
hist(cor_tc_df$model2, main = sprintf("Cor mean = %.3f", mean(cor_tc_df$model2)))

hist(cor_full_df$model3, main = sprintf("Cor mean = %.3f", mean(cor_full_df$model3)))
hist(cor_tc_df$model3, main = sprintf("Cor mean = %.3f", mean(cor_tc_df$model3)))



# plot(cor_full_df$iter, cor_full_df$gv_tc, col = "green", lwd=2, ylim = c(0,1), type="l")
# lines(cor_full_df$iter, cor_full_df$pheno, pch = 16, col = "blue")
# lines(cor_full_df$iter, cor_full_df$model1, pch = 16, col = "pink")
# lines(cor_full_df$iter, cor_full_df$model2, pch = 16, col = "magenta")
# lines(cor_full_df$iter, cor_full_df$model3, pch = 16, col = "purple4")
# legend("bottomright", legend = c("gv_tc","pheno","model1","model2","model3"),
#        col = c("green","blue","pink","magenta","purple4"), lwd =1, bty = "n")
# 
# plot(cor_tc_df $iter, cor_tc_df $gv_tc, col = "green", lwd=2, ylim = c(0,1), type="l")
# lines(cor_tc_df $iter, cor_tc_df $pheno, pch = 16, col = "blue")
# lines(cor_tc_df $iter, cor_tc_df $model1, pch = 16, col = "pink")
# lines(cor_tc_df $iter, cor_tc_df $model2, pch = 16, col = "magenta")
# lines(cor_tc_df $iter, cor_tc_df $model3, pch = 16, col = "purple4")
# legend("bottomright", legend = c("gv_tc","pheno","model1","model2","model3"),
#        col = c("green","blue","pink","magenta","purple4"), lwd =1, bty = "n")
# 
# plot(var_df$iter, var_df$gv_full, pch=10,col = "green", type="l", lwd=2, ylim= range(var_df[, c("gv_full","gv_tc","pheno","model1","model2","model3")]))
# lines(var_df$iter, var_df$gv_tc, pch = 16, col = "blue")
# lines(var_df$iter, var_df$pheno, pch = 16, col = "black")
# lines(var_df$iter, var_df$model1, pch = 16, col = "pink")
# lines(var_df$iter, var_df$model2, pch = 16, col = "magenta")
# lines(var_df$iter, var_df$model3, pch = 16, col = "purple4")
# # points(var_df$tester, var_df$gv_tc,  col="blue",    pch=16)
# # points(var_df$tester, var_df$pheno,  col="black",   pch=16)
# # points(var_df$tester, var_df$model1, col="pink",    pch=16)
# # points(var_df$tester, var_df$model2, col="magenta", pch=16)
# # points(var_df$tester, var_df$model3, col="purple4", pch=16)
# legend("topleft", legend = c("gv_full","gv_tc","pheno","model1","model2","model3"),
#        col = c("green","blue","grey50","pink","magenta","purple4"), lwd =1, bty = "n")
# 
boxplot(overlap ~ factor(method, levels = c("gv_tc","pheno","model1","model2","model3")), data = rank_df)
hist(rank_df$overlap[rank_df$method == "gv_tc"])
hist(rank_df$overlap[rank_df$method == "pheno"])
hist(rank_df$overlap[rank_df$method == "model1"])
hist(rank_df$overlap[rank_df$method == "model2"])
hist(rank_df$overlap[rank_df$method == "model3"])

#     cor_list[[i]] <- c((cor(gca_full_A_trait2$GCA, gca_testcross_A_trait2$GCA_tc)),cor(gca_full_A_trait2$GCA, pheno_gca_[ntesters]t_A_trait2$mean_y.Trait2), 
#                        cor(gca_full_A_trait2$GCA,asreml::predict(model_testcross1, classify = "mother_poolA", only = "mother_poolA")),
#                        cor(gca_full_A_trait2$GCA,asreml::predict(model_testcross2, classify = "mother_poolA", only = "mother_poolA")),
#                        cor(gca_full_A_trait2$GCA,asreml::predict(model_testcross3, classify = "mother_poolA", only = "mother_poolA")))
#     
#     mean_list[[i]] <- c(mean(gca_full_A_trait2$GCA), mean(gca_testcross_A_trait2$GCA_tc), mean(heno_gca_[ntesters]t_A_trait2$mean_y.Trait2),
#                         mean(asreml::predict(model_testcross1, classify = "mother_poolA", only = "mother_poolA")),
#                         mean(asreml::predict(model_testcross2, classify = "mother_poolA", only = "mother_poolA")),
#                         mean(asreml::predict(model_testcross3, classify = "mother_poolA", only = "mother_poolA"))))
# 
#     var_list[[i]] <- c(popVar(gca_full_A_trait2$GCA), popVar(gca_testcross_A_trait2$GCA_tc))
#     ranking_intercept[[i]] <- length(intersect(gca_full_A_trait2$mother_id[order(gca_full_A_trait2$GCA, decreasing = TRUE)][1:top_n],
#                               gca_testcross_A_trait2$mother_id[order(gca_testcross_A_trait2$GCA_tc, decreasing = TRUE)][1:top_n]))
# }
# sort(unlist(idx_list))
# plot_hist(unlist(cor_list))
# plot_hist(unlist(lapply(mean_list, function(x) x[1])))
# plot_hist(unlist(lapply(mean_list, function(x) x[2])))
# plot_hist(unlist(lapply(var_list, function(x) x[2])))
# plot(unlist(lapply(ranking_list, function(x) x[1])))
```

```{r GCA from testcross several testers}

ntesters <- c(1,3,5,10,20)
nsamples <- 40
top_n <- 10
top_true <- as.numeric(gca_full_A_trait2$mother_id[order(gca_full_A_trait2$GCA, decreasing = TRUE)][1:top_n])
cor_full_list <- cor_tc_list <- mean_list <- var_list <- ranking_intercept <- idx_list <- c()
ctr <- 0

for(k in ntesters){
  for(i in 1:nsamples){
    ctr <- ctr + 1
    cat("ntesters:",k, "it:",i,"\n")
  
  # Subset of random testers from poolB
    testers_idx <- sample(poolB@id, k, replace = FALSE)
    tester_set <- paste(sort(testers_idx), collapse = ",")
    
  # popVar((gv_table_trait2[, testers_idx])) # mean GCA females with the crosses with the 3 random testers
  # popVar(gca_full_A_trait2)
  # Correlation between the true GCA females from the full factorial cross and the GCA from the 3 testers
   gca_testcross_A_trait2 <- data.frame(mother_id = rownames(gv_table_trait2),
                                       GCA_tc = rowMeans(cbind(gv_table_trait2[, testers_idx])))
  
  # Environmental variance 
  gv_df_k_testers <- droplevels(gv_df[gv_df$father_poolB %in% testers_idx, ])

  # (varE <- diag(varG(hybridpop))/h2 - diag(varG(hybridpop))) 
  
  ngenos_tc_k <- 40 * k
  nplots_tc_k <- ngenos_tc_k * nreps
  ncols_tc_k <- 10
  nrows_tc_k <- nplots_tc_k / ncols_tc_k

  varE <- c(TraitA  = var(gv_df_k_testers$gv.TraitA)/h2 - var(gv_df_k_testers$gv.TraitA), 
            TraitAD = var(gv_df_k_testers$gv.TraitAD)/h2 - var(gv_df_k_testers$gv.TraitAD))
  
  error_df <- FieldSimR::field_trial_error(varR = varE,
                                           ntraits = 2,
                                           nenvs = nenvs,
                                           nblocks = nblocks,
                                           ncols = ncols_tc_k,  
                                           nrows = nrows_tc_k,
                                           spatial.model = "AR1")
  
  gv_df2 <- gv_df_k_testers[, c(1, 4, 5, 6, 7)]
  pheno_df <- make_phenotypes(gv.df = gv_df2, error_df, randomise = T)
  pedigree <- gv_df_k_testers %>% select(id, mother_poolA, father_poolB) %>% distinct(id, .keep_all = TRUE)
  pheno_df <- pheno_df %>% left_join(pedigree, by = "id")
  
  #Obtaining GCA from the phenotypic data without a model
  pheno_gca_nomodels <- pheno_df %>% group_by(mother_poolA) %>% summarise(GCA_pheno = mean(y.Trait2)-mean(pheno_df$y.Trait2)) %>% ungroup()
  
  # Obtain the GCA using the three ASReml models
  
  model_testcross1 <- asreml(fixed = y.Trait2 ~ father_poolB - 1, 
                             random = ~ mother_poolA + block, 
                             residual = ~units,
                             data = pheno_df)
  
  model_testcross2 <- asreml(fixed = y.Trait2 ~ father_poolB - 1, 
                             random = ~ mother_poolA +
                               block, 
                             residual = ~ar1(col):ar1(row),
                             data = pheno_df)
  
  model_testcross3 <- asreml(fixed = y.Trait2 ~ father_poolB - 1, 
                             random = ~ vm(mother_poolA, GRM_A) +                                                      
                               block, 
                             residual = ~ar1(col):ar1(row),
                             data = pheno_df)
  
  m1 <- model_testcross1$coefficients$random %>% as.data.frame() %>% 
    rownames_to_column(var = "mother_id") %>% filter(grepl("^mother_poolA", mother_id)) %>% 
    mutate(mother_id = sub(".*_", "", mother_id), effect) 
  
  m2 <- model_testcross2$coefficients$random %>% as.data.frame() %>% 
    rownames_to_column(var = "mother_id") %>% filter(grepl("^mother_poolA", mother_id)) %>% 
    mutate(mother_id = sub(".*_", "", mother_id), effect)
  
  m3 <- model_testcross3$coefficients$random %>% as.data.frame() %>% 
    rownames_to_column(var = "mother_id") %>% filter(grepl("mother_poolA", mother_id)) %>% 
    mutate(mother_id = sub(".*_", "", mother_id), effect)
  
  top_tc_gv <- as.numeric(gca_testcross_A_trait2$mother_id[order(gca_testcross_A_trait2$GCA_tc, decreasing = TRUE)][1:top_n])
  top_tc_pheno_nomodel <- as.numeric(pheno_gca_nomodels$mother_poolA[order(pheno_gca_nomodels$GCA_pheno, decreasing = TRUE)][1:top_n])
  top_tc_gca_model1 <- as.numeric(m1$mother_id[order(m1$effect, decreasing = TRUE)][1:top_n])
  top_tc_gca_model2 <- as.numeric(m2$mother_id[order(m2$effect, decreasing = TRUE)][1:top_n])
  top_tc_gca_model3 <- as.numeric(m3$mother_id[order(m3$effect, decreasing = TRUE)][1:top_n])
  
  idx_list[[ctr]] <- data.frame(ntesters = k,
                                  iter = i,
                                  tester_set = tester_set)
  
  cor_full_list[[ctr]] <- data.frame(ntesters = k,
                                    iter = i,
                                    tester_set = tester_set,
                                    gv_tc  = cor(gca_full_A_trait2$GCA, gca_testcross_A_trait2$GCA_tc),
                                    pheno  = cor(gca_full_A_trait2$GCA, pheno_gca_nomodels$GCA_pheno),
                                    model1 = cor(gca_full_A_trait2$GCA, m1$effect),
                                    model2 = cor(gca_full_A_trait2$GCA, m2$effect),
                                    model3 = cor(gca_full_A_trait2$GCA, m3$effect))
  
  cor_tc_list[[ctr]] <- data.frame(ntesters = k,
                                    iter = i,
                                    tester_set = tester_set,
                                    gv_tc  = cor(gca_full_A_trait2$GCA, gca_testcross_A_trait2$GCA_tc),
                                    pheno  = cor(gca_testcross_A_trait2$GCA, pheno_gca_nomodels$GCA_pheno),
                                    model1 = cor(gca_testcross_A_trait2$GCA, m1$effect),
                                    model2 = cor(gca_testcross_A_trait2$GCA, m2$effect),
                                    model3 = cor(gca_testcross_A_trait2$GCA, m3$effect))
  
  mean_list[[ctr]] <- data.frame(ntesters = k,
                                     iter = i,
                                     tester_set = tester_set,
                                     gv_full = mean(gca_full_A_trait2$GCA),
                                     gv_tc   = mean(gca_testcross_A_trait2$GCA_tc),
                                     pheno   = mean(pheno_gca_nomodels$GCA_pheno),
                                     model1  = mean(m1$effect),
                                     model2  = mean(m2$effect),
                                     model3  = mean(m3$effect))
  
  var_list[[ctr]] <- data.frame(ntesters = k,
                                    iter = i,
                                    tester_set = tester_set,
                                    gv_full = popVar(gca_full_A_trait2$GCA),
                                    gv_tc   = popVar(gca_testcross_A_trait2$GCA_tc),
                                    pheno   = popVar(pheno_gca_nomodels$GCA_pheno),
                                    model1  = popVar(m1$effect),
                                    model2  = popVar(m2$effect),
                                    model3  = popVar(m3$effect))
  
  ranking_intercept[[ctr]] <- data.frame(ntesters = k,
                                         iter = i,
                                         tester_set = tester_set,
                                         method = c("gv_tc", "pheno", "model1", "model2", "model3"),
                                         overlap = c(gv_tc  = length(intersect(top_true, top_tc_gv)),
                                                     pheno  = length(intersect(top_true, top_tc_pheno_nomodel)),
                                                     model1 = length(intersect(top_true, top_tc_gca_model1)),
                                                     model2 = length(intersect(top_true, top_tc_gca_model2)),
                                                     model3 = length(intersect(top_true, top_tc_gca_model3))))
  
} }

# Summaries/plots
sort(unlist(idx_list))
cor_full_df <- dplyr::bind_rows(cor_full_list)
cor_tc_df   <- dplyr::bind_rows(cor_tc_list)
mean_df     <- dplyr::bind_rows(mean_list)
var_df      <- dplyr::bind_rows(var_list)
rank_df     <- dplyr::bind_rows(ranking_intercept)
idx_df      <- dplyr::bind_rows(idx_list)


cor_full_mean <- aggregate(cbind(gv_tc, pheno, model1, model2, model3) ~ ntesters,
          data = cor_full_df, FUN = mean, na.rm = TRUE)

plot(cor_full_mean$ntesters, cor_full_mean$gv_tc, col = "blue", ylim = c(0,1), type="l",xaxt="n")
axis(1, at = cor_full_mean$ntesters)
lines(cor_full_mean$ntesters, cor_full_mean$pheno, pch = 16, col = "black")
lines(cor_full_mean$ntesters, cor_full_mean$model1, pch = 16, col = "pink")
lines(cor_full_mean$ntesters, cor_full_mean$model2, pch = 16, col = "magenta")
lines(cor_full_mean$ntesters, cor_full_mean$model3, pch = 16, col = "purple4")
legend("bottomright", legend = c("gv_tc","pheno","model1","model2","model3"),
       col = c("blue","grey50","pink","magenta","purple4"), lwd =1, bty = "n")

cor_tc_mean <- aggregate(cbind(gv_tc, pheno, model1, model2, model3) ~ ntesters,
          data = cor_tc_df, FUN = mean, na.rm = TRUE)

plot(cor_tc_mean$ntesters, cor_tc_mean$gv_tc, col = "blue", ylim = c(0,1), type="l",xaxt="n")
axis(1, at = cor_tc_df$ntesters)
lines(cor_tc_mean$ntesters, cor_tc_mean$pheno, pch = 16, col = "black")
lines(cor_tc_mean$ntesters, cor_tc_mean$model1, pch = 16, col = "pink")
lines(cor_tc_mean$ntesters, cor_tc_mean$model2, pch = 16, col = "magenta")
lines(cor_tc_mean$ntesters, cor_tc_mean$model3, pch = 16, col = "purple4")
legend("bottomright", legend = c("gv_tc","pheno","model1","model2","model3"),
       col = c("blue","grey50","pink","magenta","purple4"), lwd =1, bty = "n")


var_mean <- aggregate(cbind(gv_full,gv_tc, pheno, model1, model2, model3) ~ ntesters,
          data = var_df, FUN = mean, na.rm = TRUE)

plot(var_mean$ntesters, var_mean$gv_full, pch=10,col = "green", type="l", lwd=2, xaxt="n",ylim= range(var_mean[, c("gv_full","gv_tc","pheno","model1","model2","model3")]))
axis(1, at = var_mean$ntesters)
lines(var_mean$ntesters, var_mean$gv_tc, pch = 16, col = "blue")
lines(var_mean$ntesters, var_mean$pheno, pch = 16, col = "black")
lines(var_mean$ntesters, var_mean$model1, pch = 16, col = "pink")
lines(var_mean$ntesters, var_mean$model2, pch = 16, col = "magenta")
lines(var_mean$ntesters, var_mean$model3, pch = 16, col = "purple4")
# points(var_mean$ntesters, var_mean$gv_tc,  col="blue",    pch=16)
# points(var_mean$ntesters, var_mean$pheno,  col="black",   pch=16)
# points(var_mean$ntesters, var_mean$model1, col="pink",    pch=16)
# points(var_mean$ntesters, var_mean$model2, col="magenta", pch=16)
# points(var_mean$ntesters, var_mean$model3, col="purple4", pch=16)
legend("topright", legend = c("gv_full","gv_tc","pheno","model1","model2","model3"),
       col = c("green","blue","black","pink","magenta","purple4"), lwd =1, bty = "n")

boxplot(overlap ~ ntesters, data = subset(rank_df, method == "pheno"))
boxplot(overlap ~ factor(method, levels = c("gv_tc","pheno","model1","model2","model3")), data = rank_df)

hist(rank_df$overlap[rank_df$method == "gv_tc"])
hist(rank_df$overlap[rank_df$method == "pheno"])
hist(rank_df$overlap[rank_df$method == "model1"])
hist(rank_df$overlap[rank_df$method == "model2"])
hist(rank_df$overlap[rank_df$method == "model3"])

#     cor_list[[i]] <- c((cor(gca_full_A_trait2$GCA, gca_testcross_A_trait2$GCA_tc)),cor(gca_full_A_trait2$GCA, pheno_gca_[ntesters]t_A_trait2$mean_y.Trait2), 
#                        cor(gca_full_A_trait2$GCA,asreml::predict(model_testcross1, classify = "mother_poolA", only = "mother_poolA")),
#                        cor(gca_full_A_trait2$GCA,asreml::predict(model_testcross2, classify = "mother_poolA", only = "mother_poolA")),
#                        cor(gca_full_A_trait2$GCA,asreml::predict(model_testcross3, classify = "mother_poolA", only = "mother_poolA")))
#     
#     mean_list[[i]] <- c(mean(gca_full_A_trait2$GCA), mean(gca_testcross_A_trait2$GCA_tc), mean(heno_gca_[ntesters]t_A_trait2$mean_y.Trait2),
#                         mean(asreml::predict(model_testcross1, classify = "mother_poolA", only = "mother_poolA")),
#                         mean(asreml::predict(model_testcross2, classify = "mother_poolA", only = "mother_poolA")),
#                         mean(asreml::predict(model_testcross3, classify = "mother_poolA", only = "mother_poolA"))))
# 
#     var_list[[i]] <- c(popVar(gca_full_A_trait2$GCA), popVar(gca_testcross_A_trait2$GCA_tc))
#     ranking_intercept[[i]] <- length(intersect(gca_full_A_trait2$mother_id[order(gca_full_A_trait2$GCA, decreasing = TRUE)][1:top_n],
#                               gca_testcross_A_trait2$mother_id[order(gca_testcross_A_trait2$GCA_tc, decreasing = TRUE)][1:top_n]))
# }
# sort(unlist(idx_list))
# plot_hist(unlist(cor_list))
# plot_hist(unlist(lapply(mean_list, function(x) x[1])))
# plot_hist(unlist(lapply(mean_list, function(x) x[2])))
# plot_hist(unlist(lapply(var_list, function(x) x[2])))
# plot(unlist(lapply(ranking_list, function(x) x[1])))
```

















**Calculating the GCA obtained from a testcross from the genetic values and the phenotypic values**

Now, we can calculate the GCA effects of the pool A from the genetic values from random testers from pool B testcross. Then, compare the accuracy of the GCA estimates from the 3 testers with the true GCA from the full factorial cross.

```{r GCA from testcross one iteration}
# Subset of random testers from poolB
(testers_idx <- sample(poolB@id, 1))
((gv_table_trait1[, testers_idx])) # mean GCA females with the crosses with the random testers

(cor(gca_full_A_trait2$GCA, (gv_table_trait2[, testers_idx]))) 
plot(gca_full_A_trait2$GCA, (gv_table_trait2[, testers_idx]), main = "GCA Pool A trait AD: True full factorial vs true testcross") 
abline(lm((gv_table_trait2[, testers_idx]) ~ gca_full_A_trait2$GCA), col = "blue", lwd = 2)

#subset of the gv_df with only the hybrids with the 3 testers, same, the 2 reps have the same gv
gv_df_1testers <- droplevels(gv_df[gv_df$father %in% testers_idx, ]) 
names(gv_df_1testers)

# Means don't change between the populations. In the hybrids with full factorial the variance is reduced by the half basically because the contribution in a full sibling family of each parent to the variance is 1/4 per each parent 1/4(18.00) + 1/4(21.59) ~ 4.5 + 5.4 = 9.9. And, of course with the testcrosses with 3 testers we have less variance because we sampled some parents, so is a less dispersed population. 


mean(gv_df_1testers$gv.TraitAD) #traitA=69.46333, traitAD=177.2884
var(gv_df_1testers$gv.TraitAD) #traitA=4.84553, traitAD=12.88481


hist(hybridpop@gv[,2], breaks = 10, freq = FALSE,
     xlim = range(c(hybridpop@gv[,2], gv_df_1testers$gv.TraitAD)),
     col = adjustcolor("navy", 0.70), border = NA,
     main = sprintf("GV Trait2\nFF mean=%.2f var=%.2f\n1T mean=%.2f var=%.2f",
                    mean(hybridpop@gv[,2]), popVar(hybridpop@gv[,2]),
                    mean(gv_df_1testers$gv.TraitAD),     popVar(gv_df_1testers$gv.TraitAD)))

# Add pool A
hist(gv_df_1testers$gv.TraitAD, breaks = 10, add = TRUE, freq = FALSE,
     col = adjustcolor("yellow", 0.25), border = NA)
                    
abline(v = mean(hybridpop@gv[,2]), col = "navy",    lty = 1, lwd = 3)
abline(v = mean(gv_df_1testers$gv.TraitAD), col = "orange", lty = 1, lwd = 3)


# hybridpop # we want the subset of 120 hybrids with testers above
# hybridpop_sample <- hybridpop[hybridpop@father %in% testers_idx]

# hybridpop_3testers <- randCross2(females = poolA, males = poolB,
#                                   nProgeny = 1, nCrosses = 120,
#                                   maleParents = testers_idx)
# table(hybridpop_3testers@father)
# table(hybridpop_3testers@mother)
# 
# meanG(hybridpop_3testers)
# varG(hybridpop_3testers)                         
```

**Field experiments**

Defining the experimental design: RCBD with 2 reps in 1 location for the testcross. Here. the main goal is to obtain the phenotypes to carry out the prediction with the testcross model in ASReml.

```{r}

library(FieldSimR)
library(dplyr)

# Experimental design parameters: testcross
nenvs <- 1
nblocks <- nreps <- 2
ngenos_tc <- (nparents/2) * 1 #number of hybrids in the testcross with 3 testers
nplots_tc <- ngenos_tc*nblocks
ncols_tc <- 8 # define number of columns in the field 
nrows_tc <- nplots_tc/ncols_tc # define number of rows from the number of columns

# Environmental variance calculated from the plot-level heritability h2 defined previously using the genetic variance of the full factorial cross
# (varE <- diag(varG(hybridpop))/h2 - diag(varG(hybridpop))) 
(varE <- c(TraitA  = var(gv_df_1testers$gv.TraitA)/h2 - var(gv_df_1testers$gv.TraitA),
           TraitAD = var(gv_df_1testers$gv.TraitAD)/h2 - var(gv_df_1testers$gv.TraitAD)))

# varG(hybridpop)/(varG(hybridpop) + varE) # double check if it matches with the h2 = 0.3
var(gv_df_1testers$gv.TraitA)/(var(gv_df_1testers$gv.TraitA) + varE[1])
var(gv_df_1testers$gv.TraitAD)/(var(gv_df_1testers$gv.TraitAD) + varE[2]) # double check if it matches with the h2 = 0.3

# line-entry mean, varG/(varG + varE/nreps): this can be defined with the varE. This is higher because we have more reps representing the genotypes in the field
# (h2_entry <- varG(hybridpop)/(varG(hybridpop) + (varE/nreps))) #0.4006176
(h2_entryA <- var(gv_df_1testers$gv.TraitA)/(var(gv_df_1testers$gv.TraitA) + (varE[1]/nreps)))
(h2_entryAD <- var(gv_df_1testers$gv.TraitAD)/(var(gv_df_1testers$gv.TraitAD) + (varE[2]/nreps)))

#From this entry-mean heritability, we can calculate the accuracy
# (sqrt(varG(hybridpop)/(varG(hybridpop) + varE/nreps)))
(sqrt(var(gv_df_1testers$gv.TraitA)/(var(gv_df_1testers$gv.TraitA) + varE[1]/nreps))) 
(sqrt(var(gv_df_1testers$gv.TraitAD)/(var(gv_df_1testers$gv.TraitAD) + varE[2]/nreps))) 

#Now we simulate the plot errors (as we are using the h2 at plot level). Depending of what we want to simulate we can change the parameters col.cor, row.cor and prop.spatial
error_df <- FieldSimR::field_trial_error(varR = varE,
                                         ntraits = 2,
                                         nenvs = nenvs,
                                         nblocks = nblocks,
                                         ncols = ncols_tc,
                                         nrows = nrows_tc,
                                         spatial.model = "AR1")
                                         # col.cor = 0.9, row.cor = 0.9,
                                         # prop.spatial = 0.99)

var(error_df$e.Trait2) #check if the variance of the errors is similar to the defined varE
par(mfrow=c(1,2))
plot_effects(error_df, effect = "e.Trait1")
plot_effects(error_df, effect = "e.Trait2")
# Now we can generate the phenotypes of the testcross population by adding the genetic values and the errors
# gv_df2 <- gv_df[, c(1, 4, 5, 6)]
gv_df2 <- gv_df_1testers[, c(1, 4, 5, 6, 7)]
names(gv_df2)
pheno_df <- make_phenotypes(gv.df = gv_df2, error_df, randomise = T)

# Recover parents info
pedigree <- gv_df_1testers %>%
  select(id, mother_poolA, father_poolB) %>%
  distinct(id, .keep_all = TRUE)

pheno_df <- pheno_df %>% left_join(pedigree, by = "id")
head(pheno_df)
plot_effects(pheno_df, effect = "y.Trait1")
plot_effects(pheno_df, effect = "y.Trait2")
par(mfrow=c(1,1))
hist(gv_df_1testers$gv.TraitAD, breaks = 10, 
     xlim = range(c( gv_df_1testers$gv.TraitAD,pheno_df$y.Trait2)),
     col = adjustcolor("yellow", 0.70), border = NA,
     main = sprintf("Trait2\nGV 1T mean=%.2f var=%.2f\nPV 1T mean=%.2f var=%.2f",
                    mean(gv_df_1testers$gv.TraitAD), popVar(gv_df_1testers$gv.TraitAD),
                    mean(pheno_df$y.Trait2), popVar(pheno_df$y.Trait2)))

# Add phenotypic values
hist(pheno_df$y.Trait2, breaks = 10, add = TRUE, 
     col = adjustcolor("darkgreen", 0.25), border = NA)
                    
abline(v = mean(gv_df_1testers$gv.TraitAD), col = "orange",    lty = 1, lwd = 3)
abline(v = mean(pheno_df$y.Trait2), col = "green", lty = 1, lwd = 3)


# par(mfrow=c(2,1))
# hist(gv_df_1testers$gv.TraitA, breaks = 20, main = sprintf("Genetic values testcross 1 tester (mean = %.2f, var = %.2f)",
#                     mean(gv_df_1testers$gv.TraitA), var(gv_df_1testers$gv.TraitA)))
# abline(v = mean(gv_df_1testers$gv.TraitA), col = "lightblue", lty = 1, lwd = 3)
# hist(pheno_df$y.Trait1, breaks = 20, main = sprintf("Phenotypic values testcross 1 tester (mean = %.2f, var = %.2f)",
#                     mean(pheno_df$y.Trait1), var(pheno_df$y.Trait1)))
# abline(v = mean(pheno_df$y.Trait1), col = "darkblue", lty = 1, lwd = 3)
```
Obtain the GCA from the phenotypes using the phenotype data frame

```{r}
# Obtain the mean per rep
pheno_gca_1t_A_trait2 <- pheno_df %>%
  group_by(mother_poolA) %>%
  summarise(mean_y.Trait2 = mean(y.Trait2)-mean(pheno_df$y.Trait2)) %>%
  ungroup()

r<-(cor(gca_full_A_trait2$GCA, pheno_gca_1t_A_trait2$mean_y.Trait2))
plot(gca_full_A_trait2$GCA, pheno_gca_1t_A_trait2$mean_y.Trait2,
     main = sprintf("GCA Pool A Trait2: full factorial vs 1 tester phenotypic(r = %.2f)", r),
     xlab = "True GCA (full factorial)",
     ylab = "GCA testcross from pheno (1 tester)",
     pch = 1, col = "grey40")

abline(lm(gca_full_A_trait2$GCA ~ pheno_gca_1t_A_trait2$mean_y.Trait2),
       col = "blue", lwd = 2)

r2<-(cor((gv_table_trait2[, testers_idx]), pheno_gca_1t_A_trait2$mean_y.Trait2))
plot((gv_table_trait2[, testers_idx]), pheno_gca_1t_A_trait2$mean_y.Trait2,
     main = sprintf("GCA Pool A Trait2: 1 tester geno vs 1 tester phenotypic(r = %.2f)", r2),
     xlab = "GCA testcross from gv (1 tester)",
     ylab = "GCA testcross from pheno (1 tester)",
     pch = 1, col = "grey40")
abline(lm(pheno_gca_1t_A_trait2$mean_y.Trait2 ~ (gv_table_trait2[, testers_idx])),
       col = "blue", lwd = 2)

```

Predicting the GCA values from the phenotypes obtained from the testcrosses with ASReml using different models and obtaining the accuracies compared to the ground truth

```{r}
library(asreml)

# Fit the testcross model to estimate GCA effects of the mothers of pool A
names(pheno_df)
# Model 1
var(error_df$e.Trait2)
model_testcross1 <- asreml(fixed = y.Trait2 ~ father_poolB - 1, 
                          random = ~ mother_poolA + block, 
                          residual = ~units,
                          data = pheno_df)
model_testcross1 <- update(model_testcross1)
(summary(model_testcross1)$varcomp)
(model_testcross1$coefficients$fixed)
(model_testcross1$coefficients$random) #GCA for pool A and block

# gca_pred_1t <- predict(model_testcross1, classify = "mother_poolA", only = "mother_poolA")
# gca_pred_1t$pvals #GCA for pool A, same as above

# Model 2 - include spatial
model_testcross2 <- asreml(fixed = y.Trait2 ~ father_poolB - 1, 
                          random = ~ mother_poolA +
                                     block, 
                          residual = ~ar1(col):ar1(row),
                          data = pheno_df)
model_testcross2 <- update(model_testcross2)
summary(model_testcross2)$varcomp
model_testcross2$coefficients$fixed
model_testcross2$coefficients$random

model_testcross3 <- asreml(fixed = y.Trait2 ~ father_poolB - 1, 
                          random = ~ vm(mother_poolA, GRM_A) +                                                      
                                     block, 
                          residual = ~ar1(col):ar1(row),
                          data = pheno_df)
model_testcross3 <- update(model_testcross3)
summary(model_testcross3)$varcom
model_testcross3$coefficients$fixed
model_testcross3$coefficients$random
# gca_pred_3t <- predict(model_testcross3, classify = "mother_poolA", only = "mother_poolA")
plot(model_testcross1$coefficients$random, model_testcross3$coefficients$random); abline(a=0, b=1)
```


```{r}
r3<-(cor(model_testcross1$coefficients$random, model_testcross2$coefficients$random))
plot(model_testcross1$coefficients$random, model_testcross2$coefficients$random,
     main = sprintf("GCA pred Trait2: 1t model 1 vs GCA pred Trait1: 1t model 2 (r = %.2f)", r3),
     xlab = "GCA predicted testcross from model 1 (1 tester)",
     ylab = "GCA predicted testcross from model 2 (1 tester)",
     pch = 1, col = "grey40")
abline(a=0,b=1,
       col = "blue", lwd = 2)

r5<-(cor(gca_full_A_trait2$GCA, model_testcross1$coefficients$random[1:40, 1]))
plot(gca_full_A_trait2$GCA, model_testcross1$coefficients$random[1:40, 1],
     main = sprintf("True GCA (full factorial) vs GCA pred Trait2: 1t model 1 (r = %.2f)", r5),
     xlab = "True GCA (full factorial)",
     ylab = "GCA predicted testcross from model 1 (1 tester)",
     pch = 1, col = "grey40")
abline(a=0,b=1,
       col = "blue", lwd = 2)

r4<-(cor(gca_full_A_trait2$GCA, model_testcross2$coefficients$random[1:40, 1]))
plot(gca_full_A_trait2$GCA, model_testcross2$coefficients$random[1:40, 1],
     main = sprintf("True GCA (full factorial) vs GCA pred Trait2: 1t model 2 (r = %.2f)", r4),
     xlab = "True GCA (full factorial)",
     ylab = "GCA predicted testcross from model 2 (1 tester)",
     pch = 1, col = "grey40")
abline(a=0,b=1,
       col = "blue", lwd = 2)



# include genomic information...
# do that via QTL genotypes (unrealistic )
# do that via SNP genotypes (realistic
```

Calculate the distance between both pools the Nei's distance and heterosis according to Gonzalez-Dieguez et al., 2025 and taken from Legarra et al., 2023: The amount of variation of dominance deviations decreases with genetic distance until the point where allele frequencies are uncorrelated, and then increases for negatively correlated frequencies. Heterosis always increases with Nei’s genetic distance. 

The correlation between additive effects between traits 1 and 2 should be close to 0 to make sure that the traits are not correlated at any way.

To calculate genetic distances and parameters related to pools divergence the SNP matrix is used: Nei's distance and Fst. However, heterosis should be calculated based on the QTL only, as heterosis is related to the dominant effects and these come from the QTL. Thus, a Nei's distance is also calculated based on the QTL only to obtain Legarra et al., 2023 heterosis

```{r}
# Calculate the allele freqs in the QTL only 

alleleFreqs_qtlA <- colMeans(M_qtlA)/2
alleleFreqs_qtlB <- colMeans(M_qtlB)/2

alleleFreqs_snpsA <- colMeans(M_snpsA)/2
alleleFreqs_snpsB <- colMeans(M_snpsB)/2

# Distance between populations with SNPs
(NeisDist <- mean((alleleFreqs_snpsA - alleleFreqs_snpsB)^2))
(Fst <- NeisDist/(mean(alleleFreqs_snpsA*(1 - alleleFreqs_snpsB)) + mean(alleleFreqs_snpsB*(1 - alleleFreqs_snpsA)))) 
(NeisDist_qtl <- mean((alleleFreqs_qtlA - alleleFreqs_qtlB)^2))

# With the dominance traits heterosis is calculated with the QTL
d = SP$traits[[2]]@domEff #The 5000 QTL
cor(SP$traits[[1]]@addEff, SP$traits[[2]]@addEff) #This makes sure that the traits are not correlated at any way
(cor_add_dom_Eff <- cor(SP$traits[[2]]@addEff, d))
mean_d = mean(d)
(yi= (nqtl*nchr)*NeisDist_qtl*mean_d)  #Heterosis Legarra et al 2023, 
(Hf1 = sum( d * (alleleFreqs_qtlA-alleleFreqs_qtlB)^2 ))	#Mid-parent heterosis, defined as the deviation from the mean of the two parental populations, was calculated as described in Falconer (1981) (p. 257 Eq. 14.8)

(nFixedOppAllele <- length( which(  alleleFreqs_qtlA == 1 & alleleFreqs_qtlB == 0 | alleleFreqs_qtlA == 0 & alleleFreqs_qtlB ==1  ) ) /(nqtl*nchr))  ##fraction of fixed QTL
(nAlmostFixedOppAllele <- length( which(  alleleFreqs_qtlA >=  0.95 & alleleFreqs_qtlB <= 0.05 | alleleFreqs_qtlA <= 0.05 & alleleFreqs_qtlB >=  0.95  ) ) /(nqtl*nchr)) ##fraction of fixed QTL, same as before but not strictly fixed as 1
(nFixedSameAllele <- length( which(  alleleFreqs_qtlA == 1 & alleleFreqs_qtlB == 1 | alleleFreqs_qtlA == 0 & alleleFreqs_qtlB == 0) ) /(nqtl*nchr)) ##fraction of fixed QTL
(nAlmostFixedsameAllele <- length( which(  alleleFreqs_qtlA >=  0.95 & alleleFreqs_qtlB >=  0.95 | alleleFreqs_qtlA <= 0.05 & alleleFreqs_qtlB <= 0.05  ) ) /(nqtl*nchr)) ##fraction of fixed QTL, same as before but not strictly fixed as 1
    
```

Drafts
```{r}
# gca_pred_3t$pvals
# (mean_gca_pred_3t <- mean(gca_pred_3t$pvals$predicted.value))
# # gca_pred_3t$pvals<- gca_pred_3t$pvals %>% mutate(gca_predictedpoolA = predicted.value - mean_gca_pred_3t)
# 
# tail(gca_pred_3t$pvals)
# 
# 
# 
# alleleFreqs_snpA <- colMeans(M_snpsA)/2 #SNPj has an allele frequency pj, so this is allele frequency of the 40 mothers in every SNP not QTL
# Z <- sweep(M_snpsA, 2, 2*alleleFreqs_snpA, "-") # the markers matrix from the SNPs (M_snpsA) in the mothers, apply by columns 2, 2pj substract so the mean is 0
# K <- 2 * sum(alleleFreqs_snpA * (1 - alleleFreqs_snpA), na.rm = TRUE)
# GRM_A <- (Z %*% t(Z)) #/ K
# dim(GRM_A)
# 
# names(pheno_df)
# svd(GRM_A)$d
# GRM_A <- GRM_A + diag(1e-5, nrow(GRM_A)) #add a small value to the diagonal to make it positive definite
# GRM_A <- GRM_A/mean(diag(GRM_A))
# model_testcross3 <- asreml(fixed = y.Trait2 ~ father_poolB - 1, 
#                           random = ~ vm(mother_poolA, GRM_A) +                                                      
#                                      block, 
#                           residual = ~ar1(col):ar1(row),
#                           data = pheno_df)
```